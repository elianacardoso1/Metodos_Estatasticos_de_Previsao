---
title: "temperatura"
output: html_document
date: "2025-01-14"
---

```{r setup, include=FALSE}
library(zoo)
library(dplyr)
library(zoo)
library(forecast)
library(kableExtra)
library(lmtest)
library(ggplot2)
library(gridExtra)
library(grid)  


```

# DESCRIÇÃO DOS DADOS

*- Qual série temporal foi escolhida? Como os dados foram obtidos?*

```{r cars, echo=TRUE, message=FALSE, warning=FALSE}
dados_temperatura <- read_csv("C:/Users/OPB/Desktop/trabalhofinal/daily-minimum-temperatures.csv")
colnames(dados_temperatura) <- c("data", "temperatura")

# Série Mensal - Temperatura Mínima Mensal Média
temperatura_mensal <- dados_temperatura %>%
  mutate(data = as.yearmon(data)) %>%
  filter(data >= as.yearmon("1982-01")) %>%
  group_by(data) %>%
  summarize(temperatura = mean(temperatura))

head(temperatura_mensal)

```
A série temporal escolhida para esta análise é referente à temperatura mínima diária registrada na cidade de Melbourne, Austrália, entre janeiro de 1982 e dezembro de 1990. Os dados foram retirados do repositório Kaggle, especificamente do conjunto chamado Minimum Daily Temperatures in Melbourne, que pode ser acessado: https://www.kaggle.com/datasets/ingwangdk/minimum-daily-temperatures-in-melbourne-10-years/data?select=daily-minimum-temperatures.csv

A série original contém dados diários sobre a temperatura mínima, mas, para facilitar a análise de tendências ao longo do tempo e identificar padrões sazonais mais evidentes, decidimos transformar os dados para uma frequência mensal. Para isso, calculamos a média mensal das temperaturas mínimas, o que resultou em uma série de 108 observações mensais.

Essa transformação foi fundamental para que pudéssemos observar melhor as variações sazonais das temperaturas, como o comportamento típico das estações do ano. Com esses dados, é possível realizar análises mais profundas sobre tendências climáticas e até mesmo aplicar modelos estatísticos para prever futuras variações, utilizando técnicas como decomposição sazonal, suavização exponencial e outros métodos de previsão de séries temporais.

*- Retirando as 12 ultimas observações para conjunto teste*

```{r echo=TRUE, message=FALSE, warning=FALSE}
conjunto_treino <- temperatura_mensal[1:(nrow(temperatura_mensal) - 12), ]
conjunto_teste <- temperatura_mensal[(nrow(temperatura_mensal) - 11):nrow(temperatura_mensal), ]

#Grafico da serie utilizando conjunto de treino 
ggplot(conjunto_treino, aes(x = data, y = temperatura)) +
  geom_line(color = "blue") +
  geom_point(color = "red") +
  labs(title = "Temperatura Mínima Mensal Média (1982-1990)", 
       x = "Data", 
       y = "Temperatura Mínima (°C)") +
  theme_minimal() 
```
Ao analisar o gráfico da série temporal das temperaturas mínimas mensais entre 1982 e 1990, é possível identificar algumas características importantes:

*Sazonalidade:* A série apresenta um comportamento sazonal claro, com variações regulares a cada 12 meses. Isso é esperado devido à translação da Terra em torno do Sol, que gera mudanças de temperatura associadas às estações do ano.

*Estacionariedade:* Aparentemente as propriedades estatísticas da série (como a média e a variância) permanecem constantes ao longo do tempo. Ou seja, a série não aparenta ter tendência na parte simples nem sazonalo, o que indica uma possível estacionalidade.


# AJUSTE DE MODELOS - ARIMA

Para a identificação do melhor modelo, o primeiro passo foi analisar as características da série temporal em questão. Para isso, foram utilizados os gráficos ACF (Função de Autocorrelação) e PACF (Função de Autocorrelação Parcial), que são ferramentas essenciais para verificar as dependências temporais da série.

O gráfico de ACF permite observar as correlações entre os valores da série em diferentes defasagens (lags). A partir dessa análise, foi possível identificar se a série apresenta uma estrutura de dependência autoregressiva (AR) ou de média móvel (MA), além de indicar a necessidade de modelagem sazonal.

O gráfico de PACF, por sua vez, ajuda a identificar a ordem dos modelos autoregressivos, permitindo entender até que ponto os valores passados influenciam o valor presente da série. Com base nas observações dos gráficos ACF e PACF, foi possível fazer suposições iniciais sobre as ordens dos componentes AR e MA, tanto na parte sazonal quanto na parte não sazonal.

Com as características da série identificadas, seguiu-se para a construção de modelos ARIMA com diferentes combinações de ordens para os componentes AR, MA e sazonal. Para cada modelo ajustado, foi calculado o AIC (Critério de Informação de Akaike), com o objetivo de selecionar o modelo mais adequado, considerando a qualidade do ajuste e a complexidade do modelo. O modelo com o menor valor de AIC foi selecionado como o mais apropriado para a série temporal.

```{r echo=TRUE, message=FALSE, warning=FALSE}
#passo 1)ACF e PACF para identificar dependências temporais
serie <- ts(conjunto_treino$temperatura, frequency = 12, start = c(1982, 1))

acf(serie, lag.max = 10*12, main = "Função de Autocorrelação (ACF) da Série Temporal")
pacf(serie, lag.max = 10*12, main = "Função de Autocorrelação Parcial (PACF) da Série Temporal")
```

Analisou-se as funções ACF e PACF para os 10 primeiros períodos, e algumas características importantes foram observadas....
*PRECISA DA INTERPRETAÇÃO*

```{r echo=TRUE, message=FALSE, warning=FALSE}
modelos <- list(
  #AR(1) parte sazonal
  arima(serie, order = c(2, 0, 0), seasonal = list(order = c(1, 0, 0))),
  arima(serie, order = c(4, 0, 0), seasonal = list(order = c(1, 0, 0))),
  arima(serie, order = c(0, 0, 2), seasonal = list(order = c(1, 0, 0))),
  arima(serie, order = c(1, 0, 1), seasonal = list(order = c(1, 0, 0))),
  #AR(2)parte sazonal
  arima(serie, order = c(2, 0, 0), seasonal = list(order = c(2, 0, 0))),
  arima(serie, order = c(0, 0, 2), seasonal = list(order = c(2, 0, 0))),
  arima(serie, order = c(1, 0, 1), seasonal = list(order = c(2, 0, 0))),
  arima(serie, order = c(3, 0, 0), seasonal = list(order = c(2, 0, 0))),
  arima(serie, order = c(4, 0, 0), seasonal = list(order = c(2, 0, 0))),
  #AR(1,0,1)parte sazonal
  arima(serie, order = c(2, 0, 0), seasonal = list(order = c(1, 0, 1))),
  arima(serie, order = c(1, 0, 1), seasonal = list(order = c(1, 0, 1))),
  arima(serie, order = c(0, 0, 2), seasonal = list(order = c(1, 0, 1))),
  arima(serie, order = c(4, 0, 0), seasonal = list(order = c(1, 0, 1))),
  # ARMA(2,2) na parte sazonal
  arima(serie, order = c(2, 0, 2), seasonal = list(order = c(2, 0, 2))),
  arima(serie, order = c(3, 0, 2), seasonal = list(order = c(2, 0, 2))),
  arima(serie, order = c(2, 0, 3), seasonal = list(order = c(2, 0, 2))),
  arima(serie, order = c(3, 0, 3), seasonal = list(order = c(2, 0, 2))))

descricao_modelos <- c(
  "ARIMA(2,0,0) sazonal(1,0,0)",
  "ARIMA(4,0,0) sazonal(1,0,0)",
  "ARIMA(0,0,2) sazonal(1,0,0)",
  "ARIMA(1,0,1) sazonal(1,0,0)",
  "ARIMA(2,0,0) sazonal(2,0,0)",
  "ARIMA(0,0,2) sazonal(2,0,0)",
  "ARIMA(1,0,1) sazonal(2,0,0)",
  "ARIMA(3,0,0) sazonal(2,0,0)",
  "ARIMA(4,0,0) sazonal(2,0,0)",
  "ARIMA(2,0,0) sazonal(1,0,1)",
  "ARIMA(1,0,1) sazonal(1,0,1)",
  "ARIMA(0,0,2) sazonal(1,0,1)",
  "ARIMA(4,0,0) sazonal(1,0,1)",
  "ARIMA(2,0,2) sazonal(2,0,2)",
  "ARIMA(3,0,2) sazonal(2,0,2)",
  "ARIMA(2,0,3) sazonal(2,0,2)",
  "ARIMA(3,0,3) sazonal(2,0,2)"
)


# Extraindo os valores de AIC de cada modelo
aic_values <- sapply(modelos, function(m) m$aic)

# Criando um dataframe para armazenar os resultados
resultado <- data.frame(
  Modelo = paste0("M", 1:length(modelos)),
  Descricao = descricao_modelos,
  AIC = aic_values
)

# Ordenando os modelos pelo menor AIC
resultado <- resultado %>% arrange(AIC)

```

A tabela abaixo apresenta os cinco modelos ARIMA com os menores valores de AIC, indicando que são as melhores especificações dentro do conjunto de modelos testado. O modelo com o menor AIC tende a ser o mais adequado para representar a série temporal, equilibrando a complexidade do modelo e a qualidade do ajuste:

```{r echo=TRUE, message=FALSE, warning=FALSE}
resultado %>%
  head(5) %>%
  kable("html", col.names = c("Modelo", "Descrição", "AIC")) %>%
  kable_styling(full_width = F, position = "center")
```

A seguir, aplicaremos o teste de significância dos coeficientes (coeftest) para cada um dos modelos mencionados. O coeftest é uma função que permite testar a significância estatística dos parâmetros do modelo, fornecendo os valores de t e p para cada coeficiente. Para um parâmetro ser considerado significativo, o valor-p deve ser inferior a um determinado nível de significância (0.05):

```{r echo=TRUE, message=FALSE, warning=FALSE}

# Lista dos modelos com os 5 menores AIC
modelos_selecionados <- list(
  arima(serie, order = c(2, 0, 2), seasonal = list(order = c(2, 0, 2))),
  arima(serie, order = c(3, 0, 3), seasonal = list(order = c(2, 0, 2))),
  arima(serie, order = c(4, 0, 0), seasonal = list(order = c(1, 0, 1))),
  arima(serie, order = c(2, 0, 0), seasonal = list(order = c(1, 0, 1))),
  arima(serie, order = c(0, 0, 2), seasonal = list(order = c(1, 0, 1)))
)

# Aplicando coeftest para cada modelo
resultados_coeftest <- lapply(modelos_selecionados, function(m) coeftest(m))

resultados_coeftest



```

Os Modelos M10 (ARIMA(2,0,0) sazonal(1,0,1)) e M12 (ARIMA(0,0,2) sazonal(1,0,1)) se destacam por terem todos os parâmetros estatisticamente significativos, o que pode indicar que eles são os mais robustos e completos entre os analisados. Desse modo, os dois modelos seriam adequados para a série temporal analisada (ressalva: para conclusão final, necessário análise resíduos)

*- Análise residuos:*

```{r echo=TRUE, message=FALSE, warning=FALSE}

# Analise heterocedasticidade dos residuos:

M10 =  arima(serie, order = c(2, 0, 0), seasonal = list(order = c(1, 0, 1)))
M12 =  arima(serie, order = c(0, 0, 2), seasonal = list(order = c(1, 0, 1)))

conjunto_treino_residuos <- conjunto_treino %>%
  mutate(
    Resíduos_M10 = M10$residuals,
    Resíduos_M12 = M12$residuals
  )

## Plot dos resíduos do Modelo M10
plot_residuos_M10 <- conjunto_treino_residuos %>%
  ggplot() +
  geom_line(aes(x = data, y = Resíduos_M10, color = "M10")) +
  labs(x = 'Tempo', y = 'Resíduos', color = 'Modelo') +
  ggtitle('Resíduos - Modelo M10') +
  theme_minimal()

## Plot dos resíduos do Modelo M12
plot_residuos_M12 <- conjunto_treino_residuos %>%
  ggplot() +
  geom_line(aes(x = data, y = Resíduos_M12, color = "M12")) +
  labs(x = 'Tempo', y = 'Resíduos', color = 'Modelo') +
  ggtitle('Resíduos - Modelo M12') +
  theme_minimal()

grid.arrange(plot_residuos_M10, plot_residuos_M12, ncol = 2)

# Analise normalidade dos residuos:

normalidadeM12 <-shapiro.test(M12$residuals)
normalidadeM10 <-shapiro.test(M10$residuals)

```
Os modelos M10 e M12 apresentam variância constante nos resíduos, o que significa que os resíduos não exibem padrões de heterocedasticidade, ou seja, a variância dos resíduos não muda ao longo do tempo. Esse comportamento é caracterizado pela ausência de uma dispersão crescente ou decrescente conforme o tempo avança. Além disso, a normalidade dos resíduos foi verificada por meio do teste de Shapiro-Wilk. Para o modelo M10, o valor-p do teste foi de 0.6597, indicando que não há evidências para rejeitar a hipótese nula de que os resíduos seguem uma distribuição normal. Para o modelo M12, o valor-p foi de 0.6589, o que também sugere que os resíduos seguem uma distribuição normal.

É importante ressaltar, além da normalidade e da variância constante, que os resíduos precisam ser independentes para garantir a adequação dos modelos. A independência dos resíduos foi testada utilizando o teste de autocorrelação (ACF e PACF) e o teste de Box-Pierce:

- Para modelo  M10 (ARIMA(2,0,0) sazonal(1,0,1)):

```{r echo=TRUE, message=FALSE, warning=FALSE}

# ACF e PACF para o modelo M10
acf_plot_M10 <- ggAcf(M10$residuals, lag.max =5*12) +
  ggtitle("ACF - Modelo M10") +
  theme_minimal()

pacf_plot_M10 <- ggPacf(M10$residuals, lag.max = 5*12) +
  ggtitle("PACF - Modelo M10") +
  theme_minimal()

# Teste de Box-Pierce
box_test_M10 <- Box.test(M10$residuals, lag = 1, type = "Ljung-Box", fitdf = 0)
p_value_box_test_M10 <- box_test_M10$p.value

# Plot ACF e PACF lado a lado com p-valor do Box-Test
grid.arrange(
  acf_plot_M10, pacf_plot_M10,
  ncol = 2,
  top = textGrob(paste("Teste de Box-Pierce - p-valor: ", round(p_value_box_test_M10, 4)), gp = gpar(fontsize = 12))
)
```
A análise dos resíduos do modelo M10 mostrou que a autocorrelação dos resíduos segue um comportamento de ruído branco, sem padrões significativos. Esse comportamento é desejável, pois significa que o modelo conseguiu capturar adequadamente as relações temporais na série. Além disso, o p-valor do teste de Box-Pierce foi de 0.98, muito superior ao nível de significância de 0.05, confirmando que os resíduos são independentes e não exibem padrões de autocorrelação. Isso reforça a adequação do modelo M10, indicando que ele não deixou informações temporais não capturadas nos resíduos.

- Para modelo M12 (ARIMA(0,0,2) sazonal(1,0,1)):

```{r echo=TRUE, message=FALSE, warning=FALSE}
# ACF e PACF para o modelo M12
acf_plot_M12 <- ggAcf(M12$residuals, lag.max = 5*12) +
  ggtitle("ACF - Modelo M12") +
  theme_minimal()

pacf_plot_M12 <- ggPacf(M12$residuals, lag.max = 5*12) +
  ggtitle("PACF - Modelo M12") +
  theme_minimal()

# Teste de Box-Pierce
box_test_M12 <- Box.test(M12$residuals, lag = 1, type = "Ljung-Box", fitdf = 0)
p_value_box_test_M12 <- box_test_M12$p.value

# Plot ACF e PACF lado a lado com p-valor do Box-Test
grid.arrange(
  acf_plot_M12, pacf_plot_M12,
  ncol = 2,
  top = textGrob(paste("Teste de Box-Pierce - p-valor: ", round(p_value_box_test_M12, 4)), gp = gpar(fontsize = 12))
)
```

A análise dos resíduos do modelo M12 também revelou um comportamento de ruído branco, semelhante ao observado no modelo M10. As funções ACF e PACF indicaram que os resíduos não apresentam autocorrelação significativa, sugerindo que não há dependência temporal entre eles. O p-valor do teste de Box-Pierce para os resíduos do modelo M12 foi de 0.9443, também muito superior ao nível de significância de 0.05, o que confirma que os resíduos são independentes e não apresentam padrões de autocorrelação. Esses resultados indicam que tanto o modelo M10 quanto o M12 geraram resíduos que seguem um padrão de ruído branco, o que reforça a adequação e a eficácia de ambos os modelos para a série temporal analisada.

# AJUSTE DE MODELOS - Alisamento Exponencial

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Decompondo a série temporal (aditiva)
decomposicao_aditiva <- decompose(serie, type = "additive")
plot(decomposicao_aditiva)

# Decompondo a série temporal (multiplicativa)
decomposicao_multiplicativa <- decompose(serie, type = "multiplicative")
plot(decomposicao_multiplicativa)

```
Os plots acima decompõe a série temporal em três componentes principais: tendência, sazonalidade e resíduo:

*Tendência:* A série parece mostrar um aumento nas temperaturas mínimas a partir de 1987, sugerindo uma tendência de aquecimento nas últimas décadas do período analisado. No entanto, é importante realizar testes estatísticos.

*Sazonalidade:*  A sazonalidade é claramente visível, com picos e vales que se repetem a cada 12 meses. Isso reflete as variações típicas de temperatura associadas às estações do ano, com temperaturas mais altas no verão e mais baixas no inverno.

*Resíduo:* O resíduo apresenta um padrão aleatório, com valores positivos e negativos distribuídos de forma equilibrada. Isso sugere que o modelo de decomposição conseguiu capturar a maior parte da variabilidade da série, deixando apenas flutuações aleatórias, ou seja, o modelo foi bem-sucedido em explicar os principais componentes da série.

Para determinar qual modelo de decomposição (aditivo ou multiplicativo) é mais adequado, é necessário realizar alguns testes e análises adicionais:

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Holt-Winters Aditivo
aehw.aditivo <- HoltWinters(serie, alpha = NULL, beta = NULL, gamma = NULL, seasonal = c("additive"))

# Extraindo o erro quadrático médio (RMSE), AIC e SSE
RMSE <- sqrt(aehw.aditivo$SSE / length(serie))
SSE <- aehw.aditivo$SSE

# Extraindo os parâmetros do modelo aditivo
parametros_aditivo <- data.frame(
  "Parâmetro" = c("Alpha", "Beta", "Gamma", "RMSE", "SSE"),
  "Valor" = c(aehw.aditivo$alpha, aehw.aditivo$beta, aehw.aditivo$gamma, 
              RMSE, SSE)
)

# Exibindo os parâmetros do modelo aditivo em formato de tabela
kable(parametros_aditivo, caption = "Parâmetros e Métricas do Modelo Aditivo de Holt-Winters") %>% 
  kable_styling(full_width = F, position = "center")
```

- RMSE (Root Mean Squared Error): Mede a precisão do modelo. Quanto menor, melhor o modelo ajusta-se aos dados.
- SSE (Soma dos Erros ao Quadrado): Mede a soma dos quadrados dos resíduos (erros), sendo uma indicação do quão bem o modelo está ajustado.

*Necessario interpretação*

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Holt-Winters Multiplicativo
aehw.multiplicativo <- HoltWinters(serie, alpha = NULL, beta = NULL, gamma = NULL, seasonal = c("multiplicative"))

# Extraindo o erro quadrático médio (RMSE), AIC e SSE
RMSE_multiplicativo <- sqrt(aehw.multiplicativo$SSE / length(serie))
SSE_multiplicativo <- aehw.multiplicativo$SSE

# Extraindo os parâmetros do modelo multiplicativo
parametros_multiplicativo <- data.frame(
  "Parâmetro" = c("Alpha", "Beta", "Gamma", "RMSE", "SSE"),
  "Valor" = c(aehw.multiplicativo$alpha, aehw.multiplicativo$beta, aehw.multiplicativo$gamma, 
              RMSE_multiplicativo, SSE_multiplicativo)
)

# Exibindo os parâmetros do modelo multiplicativo em formato de tabela
kable(parametros_multiplicativo, caption = "Parâmetros e Métricas do Modelo Multiplicativo de Holt-Winters") %>% 
  kable_styling(full_width = F, position = "center")
```
*Necessário interpretação*


Como Soma de Quadrados dos Erros de Previsão (SSE) foi menor no modelo aditivo,esse será utilizado para as previsões


*(DUVIDA- EM DECORRENCIA DA SAZONALIDADE, geralmente modelo multiplicativo é utilizado)*

# Previsões usando AEHW aditivo

```{r}
previsao <- predict(aehw.aditivo, n.ahead = 11, prediction.interval = T,
level = 0.95, interval = "prediction")
a <- ts(conjunto_teste$temperatura, frequency = 12, start = 1990)
plot(aehw.aditivo, previsao, lwd =2, col = "black", xlab = "Ano", ylim = c(0,20))
lines(a, col = "black", lwd = 1)
```
*Necessário interpretação*

# Comparação dos Modelos

